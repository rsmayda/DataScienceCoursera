# Debugging tools

printmessage <- function(x) {
    if(x > 0)
        print("x is greater than zero")
    else
        print("x is less than or equal to zero")
    invisible(x) # Stops the 'auto-print' BUT returns x
}

x<-printmessage(1)
x

printmessage2 <- function(x) {
    if (is.na(x))
        print("x is missing value!")
    else if(x > 0)
        print("x is greater than zero")
    else
        print("x is less than or equal to zero")
    invisible(x) # Stops the 'auto-print' BUT returns x
}


# Something is wrong you get:
# message: A generic notification/diagnostic message produced by the message
#   function; execution of the function continues
printmessage2(NA)
# warning: An indication that something is wrong but not necessarily fatal;
#   execution of the function continues; generated by the warning function
log(-1)
# error: An indication that a fatal problem has occurred; execution stops;
#   produced by the stop function
printmessage(NA)
# condition: A generic concept for indicating that something unexpected can
#   occur; programmers can create their own conditions

# Debugging process
# -How do you know that something is wrong with your function?
# -What was your input? How did you call the function?
# -What were you expecting? Output, messages, other results?
# -What did you get?
# -How does what you get differ from what you were expecting?
# -Were your expectations correct in the first place?
# -Can you reproduce the problem (exactly)? (important when using ran #)

# The primary tools for debugging functions in R are
# -traceback: prints out the function call stack after an error occurs; does
#    nothing if there’s no error
mean(z)
traceback()
lm(y~x)
traceback()
# -debug: flags a function for “debug” mode which allows you to step through
#    execution of a function one line at a time
debug(printmessage)
printmessage(NA) # n = next; able to next by calling debug() in debugger
# -browser: suspends the execution of a function wherever it is called and puts
#    the function in debug mode
# -trace: allows you to insert debugging code into a function a specific places
# -recover: allows you to modify the error behavior so that you can browse the
#    function call stack
options(error = recover)
read.csv("nosuchfile")

# Summary
# There are three main indications of a problem/condition: message, warning, error
#   -only an error is fatal
# When analyzing a function with a problem, make sure you can reproduce the
#   problem, clearly state your expectations and how the output differs from your
#   expectation
# Interactive debugging tools traceback, debug, browser, trace, and recover can
#   be used to find problematic code in functions
# Debugging tools are not a substitute for thinking!



